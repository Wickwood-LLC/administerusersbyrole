<?php

use Drupal\Core\Url;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Session\AccountInterface;
use Drupal\User\UserInterface;

/**
 * Generates a permission string for a given a role name.
 */
function _administerusersbyrole_build_perm_string($role_id, $op = 'edit') {
  $perm = "$op users with role $role_id";
  return $perm;
}

/**
 * Implements hook_ENTITY_TYPE_access() for entity type "user".
 *
 * @param \Drupal\User\UserInterface $user
 *   The user object to check access for.
 *
 * @param string $operation: The operation that is to be performed on $entity.
 *
 * @param \Drupal\Core\Session\AccountInterface $account: The account trying to access the entity.
 */
function administerusersbyrole_user_access(UserInterface $user, $op, AccountInterface $account) {
  // Never allow uid 0 (anonymous) or 1 (master admin).
  if ($user->id() <= 1) {
    return AccessResult::neutral();
  }

  $convert = array('delete' => 'cancel', 'update' => 'edit');
  if (!isset($convert[$op])) {
    return AccessResult::neutral();
  }

  $roles = $user->getRoles();
  foreach ($roles as $rid) {
    // If there is only AUTHENTICATED_ROLE, then we must test for it, otherwise skip it.
    if (($rid == AccountInterface::AUTHENTICATED_ROLE) && (count($roles) > 1)) {
      continue;
    }

    if (!$account->hasPermission(_administerusersbyrole_build_perm_string($rid, $convert[$op]))) {
      return AccessResult::neutral();
    }
  }

  return AccessResult::allowed()->cachePerPermissions();
}

/**
 * Implements hook_help().
 */
function administerusersbyrole_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.administerusersbyrole':
      $output = '<h3>About</h3>';
      $output .= "<p>Administer Users by Role llows site builders to set up fine-grained permissions for
          allowing \"sub-admin\" users to edit and delete other users ? more specific
          than Drupal Core's all-or-nothing 'administer users' permission. It also
          provides and enforces a 'create users' permission. <br />";

      $output .= "Manage users, role and permissions in <a href=\"!pa_url\">People Administration page</a></p>";
      $output .= "<br><h3>New permissions</h3>";
      $output .= "<h6>Create new users</h6>";
      $output .= "Create users, at admin/people/create. If in the account settings (/admin/config/people/accounts) the administrator select that Visitors can register accounts but administrator approval is required, the accounts created will be as blocked account. If the administrator select that Visitors can create accounts, the accounts created will be as active";

      $output .= "<h6>Edit users with no custom roles</h6>";
      $output .= "Allows editing of any authenticated user that has no custom roles set.";
      $output .= "<h6>Edit users with no custom roles</h6>";
      $output .= "Allows editing of any authenticated user with the specified role.
        To edit a user with multiple roles, the sub-admin must have permission to
        edit ALL of those roles.  (\"Edit users with no custom roles\" is NOT needed.)";

      $output .= "<h6>Edit users with {role} role</h6>";

      $output .= "Allows edit accounts that have a custom role that the administrator creates <br />";

      $output .= "<br><strong>The permission for cancel work exactly the same as those for edit.</strong>";

      return t($output, array('!pa_url' => Url::fromRoute('entity.user.collection')));
      break;
  }
}
